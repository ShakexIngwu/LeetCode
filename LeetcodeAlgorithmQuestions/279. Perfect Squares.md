# Solution1: Dynamic Programming

Considering the subproblem in this problem, given `n`, `numSquares(n) = min{numSquares(n), numSquares(n-j*j)+1, numSquares(n-(j-1)*(j-1))+1, ..., numSquares(n - 1*1)+1}` s.t. `j*j<=n`.  

Based on the above recursion equation, we could make use of Dynamic programming cause this question satisfies the two requirements of DP:  
1. Overlapping subproblem   
2. Optimal substructure  

The overlapping subproblem lies in that in the above equation, we will consider the subproblems in the `min{}` part again and again. And optimal substructure lies in that the optimal solution to a subproblem ranging from `(n-j*j) to 1` can always make up the possible global optimal solution for `n`.  

As a result, we have the following implementation.  

Time complexity: `O(n*n^(1/2) + (n-1)*((n-1)^1/2 + ... + 1*1^1/2) = 2/5 * n^(5/2)`. This is generted using Eulerâ€“Maclaurin formula.  

Space complexity: `O(n)`.  

```Java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        for (int i = 1; i <= n; i++) {
            // try every possible j s.t. j*j<i
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        
        return dp[n];
    }
}
```

# Solution2: BFS looking for shortest path

We can also 

```Java
class Solution {
    public int numSquares(int n) {
        if (n <= 0) return 0;
        
        List<Integer> squares = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            squares.add(i * i);
        }
        
        int currCount = 0;
        Deque<Integer> deque = new ArrayDeque<>();
        deque.offer(0);
        while (!deque.isEmpty()) {
            currCount++;
            int currLen = deque.size();
            for (int i = 0; i < currLen; i++) {
                int tmp = deque.poll();
                for (int j = 0; j < squares.size(); j++) {
                    if (tmp + squares.get(j) == n) {
                        return currCount;
                    } else if (tmp + squares.get(j) < n) {
                        deque.offer(tmp + squares.get(j));
                    } else {
                        break;
                    }
                }
            }
        }
        
        return 0;
    }
}
```
