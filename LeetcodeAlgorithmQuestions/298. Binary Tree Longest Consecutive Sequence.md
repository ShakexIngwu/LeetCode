# Solution1: Top-down DFS

Searching for longest consecutive sequence from top to bottom. A consecutive sequence is made up by the parent node's value less than its child node's value by exactly by 1. And this child node can either be its left or right child. Meanwhile, the longest consecutive sequence can either be generated by a sequence ending at current node or spanning into child nodes or only by child nodes. Hence we should return the largest value among those three possibilities.   

Time complexity: `O(n)` given there are `n` nodes in the tree.  

Space complexity: `O(n)` for the recursion stack. 

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int longestConsecutive(TreeNode root) {
        return getLongestConsecutive(root, null, 0);
    }
    
    private int getLongestConsecutive(TreeNode child, TreeNode parent, int len) {
        if (child == null) return 0;
        len = (parent != null && parent.val == child.val - 1) ? len + 1 : 1;
        return Math.max(len, 
                        Math.max(
                            getLongestConsecutive(child.left, child, len),
                            getLongestConsecutive(child.right, child, len)
                        )
                       );
    }
}
```

# Solution2: Bottom-up DFS

The same with the above idea, we still need to check both left and right child of a parent node to get the result. The difference in the values of parent and child need to be 1, i.e. parent's value need to be less than child's value by 1.  

This time we keep a global variable to make the process more intuitive, since the `result` is an `int` and `int` is a primitive type thus we cannot change it within another function.  

We check the left and right subtree of a node, and record the length. There are 2 conditions:   
1. If `parent.val == child.val - 1`, then the current length should be the maximum one among `left + 1` and `right + 1`.  
2. Otherwise, current length should be 1 since current node is the only one that is consecutive.  

Then we update `result` correspondingly.  

Time complexity: `O(n)` given there are `n` nodes in the tree.  

Space complexity: `O(n)` for the recursion stack.  

```Java
class Solution {
    int result = 0;
    public int longestConsecutive(TreeNode root) {
        if (root == null) {
            return 0;
        }
        getLongestConsecutive(root);
        return result;
    }
    
    private int getLongestConsecutive(TreeNode root) {
        int ret = 1;
        
        if (root.left != null) {
            int left = getLongestConsecutive(root.left);
            if (root.val == root.left.val - 1) {
                ret = Math.max(ret, 1 + left);
            }
        }
        
        if (root.right != null) {
            int right = getLongestConsecutive(root.right);
            if (root.val == root.right.val - 1) {
                ret = Math.max(ret, 1 + right);
            }
        }
        
        result = Math.max(result, ret);
        return ret;
    }
}
```
